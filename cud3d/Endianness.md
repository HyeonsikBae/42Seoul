# Endianness

---

엔디언(Endianness)은 데이터를 어떤 순서로 메모리 위치에 저장시킬 것인지를 정하는 방식이다.

엔디언은 빅 엔디언, 리틀 엔디언, 미들 엔디언이라는 세 가지 방식이 있다.

이런 엔디언 방식을 이해하기 위해서는 메모리에 데이터가 어떻게 저장되는지를 아는 것이 중요하다.



### Byte Order

ByteOrder한 명칭에서 알 수 있듯이 Byte 와 Order로 이루어져 있다.

각각의 단어가 의미하는 바를 알아보자.

Byte : 컴퓨터에서 저장하는 최소 데이터 단위인 1 Byte.

Order : 데이터를 어떤 순서(Order)로 읽어서 저장할 것인가

예시를 들기 위해 아래와 같은 데이터와 주소가 있다고 가정해보자

| Data    | E    | N    | D    | I    | A    | N    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| Address | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 |

위 데이터의 내용은 "ENDIAN"이고 주소는 0x00 부터 1 byte씩 저장되어 있다.

이것을 Byte 단위로 상위비트부터 하위비트로의 Order에 맞춰 저장하면 "ENDIAN"이란 값이 저장되는 것이다.

반대로 Byte 단위로 하위비트부터 Order에 맞춰 저장하면 "NAIDNE"란 값이 저장된다.

이 순서를 위에서 언급한 엔디언으로 지정할 수 있다.



### BitOrder

BitOrder는 위 ByteOrder를 봤다면 금방 이해가 될 것이다.

1Byte는 8Bit로 이루어져있고, 이것을 순서대로 저장하는 것이 BitOrder이다.

하지만 ByteOrder와 다른 점이라면 bit는 무조건 상위비트부터 저장한다는 점이다.



### 엔디언

엔디언에는 세 가지 방식이 있다고 언급했다.

이 세 가지 방식에 대해서 알아보자.

1. 빅 엔디언 (Big Endianness)

   상위 비트부터 데이터를 읽어서 저장하는 방식이다.

   16진수 0x12345678 을 스택에 저장하게 되면 아래와 같이 저장된다.

   ![big_endian](https://github.com/HyeonsikBae/42Seoul/blob/master/cud3d/big_endian_example.png)

2. 리틀 엔디언 (Little Endianness)

   하위 비트부터 데이터를 읽어서 저장하는 방식이다.

   16진수 0x12345678 을 스택에 저장하게 되면 아래와 같이 저장된다.

   ![little_endian](https://github.com/HyeonsikBae/42Seoul/blob/master/cud3d/little_endian_example.png)

3. 미들 엔디언 (Middle Endianness)

   빅 엔디언, 리틀 엔디언 두 방식 모두 지원하거나 두 방식 모두 속하지 않는 방식이다.

위에서 알 수 있듯 빅 엔디언과 리틀 엔디언은 메모리에 데이터의 저장 순서가 다르다.

그렇기 때문에 서로 다른 엔디언을 사용하는 CPU 간 데이터 통신을 할 때에는 Network Byte Order를 통해 엔디언 방식을 알 수 있도록 해 주어야 한다.



### Big Endian vs Little Endian

- CPU

  두 가지 방식의 엔디언은 전형적으로 CPU에 의해 결정된다.

  | Big Endian | Little Endian |
  | ---------- | ------------- |
  | Intel      | IBM           |
  | AMD        | SPARC         |
  | DEC        | Motorola      |

  

- 디버깅

  프로그래밍을 하다 보면 디버깅을 해야 할 일이 생긴다.

  이 때, 엔디언 방식에 따라 디버깅이 비교적 쉽고 어려울 수 있는데, Big Endian을 채택하는 편이 디버깅에 더 용이하다.

  0x12345678 의 16진수를 Little Endian으로 저장하면 78, 56, 34, 12 의 순서로 저장된다.

  하지만 이를 Big Endian으로 저장하면 12, 34, 56, 78의 순서로 저장되고 이는 사람이 숫자를 읽을 때와 같아서 더 직관적이다.

  

- 덧셈 속도

  간단한 덧셈 연산으로 엔디언의 연산 속도의 차이를 확인할 수 있다.

  연산은 낮은 자리의 수부터 더해서 올림이 발생하면 이를 높은 자리의 수에 반영해야 한다.

  빅 엔디언의 경우에는 높은 자리의 수부터 연산하므로 낮은 자리의 수에서 올림이 발생하면 이를 다시 연산해주어야 한다.

  하지만 리틀 엔디언의 경우에는 낮은 자리의 수부터 연산하므로 올림을 바로바로 적용할 수 있다.

  고로 연산을 할 때에는 리틀 엔디언의 속도가 더 빠르다.

  

- 대소 비교

  대소 비교는 연산 속도와 반대의 경우를 들 수 있다.

  숫자를 비교할 때, 제일 큰 자리의 수부터 비교를 하면 낮은 숫자의 비교없이 숫자의 대소를 비교할 수 있다.

  높은 자리의 수부터 비교를 하게 되는 빅 엔디언의 형식이 리틀 엔디언보다 대소 비교의 연산 속도가 빠르다.